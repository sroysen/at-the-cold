#!/usr/bin/python

import shutil
import sys
import os
import subprocess
import socket, struct 
import pdb
from string import Template
from optparse import OptionParser
import json
import bson
import pickle
import pprint
import pymongo
import time
import signal
import logging
import glob

#######################################
# Constants used by the system        #
#######################################
# Init script used by the system if no init scrip file is provided
init_scrip = """
#!/bin/bash
#
# mongod - Startup script for mongod
# Generated by $ClusterInABox
# All modifications here will be lost if the cluster is recreated from scratch

MONGO_INSTANCE=$NameOfInstance
CONFIGFILE=$MongoConfigFile
PIDFILE=$MongoPIDFile
mongod=$mongod_binary
OPTIONS=" -f $CONFIGFILE"

if [ -f "/etc/rc.d/init.d/functions" ]; then
	. /etc/rc.d/init.d/functions
	KILLPROC_OPT="-d 300"
	KILL_SIGNAL="-15"
else
	. /lib/lsb/init-functions
	KILLPROC_OPT=""
	KILL_SIGNAL="KILL"
fi


start()
{
  echo -n $"Starting mongod instance: $MONGO_INSTANCE"
  $mongod $OPTIONS
  RETVAL=$?
  echo
  [ $RETVAL -eq 0 ] || echo "Error starting mongo instance $MONGO_INSTANCE"
}

stop()
{
  echo -n $"Stopping mongod: "
  killproc -p "$PIDFILE" $KILLPROC_OPT $mongod 
  RETVAL=$?
  echo
  [ $RETVAL -eq 0 ] || echo "Error stopping mongo instance $MONGO_INSTANCE"
}

mykill()
{
  echo -n $"Killing mongod: "
  killproc -p "$PIDFILE" $KILLPROC_OPT $mongod $KILL_SIGNAL
  RETVAL=$?
  echo
  [ $RETVAL -eq 0 ] || echo "Error killing mongo instance $MONGO_INSTANCE"
}


restart () {
	stop
	start
}

RETVAL=0

case "$1" in
  start)
    start
    ;;
  stop)
    stop
    ;;
  restart|reload|force-reload)
    restart
    ;;
  condrestart)
    echo "Not Implemented"
    ;;
  status)
    echo "Not Implemented"
    ;;
  really-kill)
    mykill
    ;;
  *)
    echo "Usage: $0 {start|stop|status|restart|reload|force-reload|condrestart|really-kill}"
    RETVAL=1
esac

exit $RETVAL
"""

###################################################
# Global variables                                #
###################################################

###################################################
# General functions                               #
###################################################

def abort_running_instance(text2log, exit_status):
    logging.critical(text2log)
    sys.exit(exit_status)

def unpack_and_make_default(version, filename, default_name, base_path):
    if not os.path.isdir(version):
         if os.path.isfile(version + '.tgz'):
             subprocess.call(['tar', '-xzf', version + '.tgz'])
             subprocess.call(['rm', default_name])
             subprocess.call(['ln', '-s', version, default_name])
         else:
             abort_running_instance('The file for the requested version does not exits ('+filename+'). Download it from http://www.mongodb.org/downloads and copy it here', 4)
    return(base_path + '/' + version)

def unpack_mongodb(version, base_path):
    mongo_default_location = base_path + '/mongodb'

    if (version != ''):
        # If a version is provided, unpack it and make it the default
        mongo_location = unpack_and_make_default(version, version + '.tgz', mongo_default_location, base_path)
    else:
        # No specific version provided. Trying to find the present ones installed
        # Try the default one first
        if os.path.isdir(mongo_default_location):
            mongo_location = mongo_default_location
        else:
            # No default directory/location. Trying to find local tgz files that we can use
            # Find the latest one (major version) in the present running directory
            try:
                filename = sorted(glob.glob('./mongodb*.tgz'), reverse=True)[0]
            except IndexError:
                abort_running_instance('There are no mongo distributions to use locally. Download a binary one (.tgz file) from http://www.mongodb.org/downloads and copy it to the running folder', 2)
            version = filename.rstrip('.tgz').lstrip('./')
            mongo_location =unpack_and_make_default(version, filename, mongo_default_location, base_path)
 
    return mongo_location

# Pretty print a dictionary or tuple
def printplus(obj):
    """
    Pretty-prints the object passed in.

    """
    # Dict
    if isinstance(obj, dict):
        for k, v in sorted(obj.items()):
            print u'{0}: {1}'.format(str(k), str(v))

    # List or tuple            
    elif isinstance(obj, list) or isinstance(obj, tuple):
        for x in obj:
            print str(x)

    # Other
    else:
        print obj

def myprettyprint(obj, result, indent):
    # Dict
    if isinstance(obj, dict):
        for k, v in sorted(obj.items()):
            print u'{0}: {1}'.format(str(k), str(v))

    # List or tuple            
    elif isinstance(obj, list) or isinstance(obj, tuple):
        for x in obj:
            print str(x)

    # Other
    else:
        print obj

# Aligns a string within specific lengts. used for conf files
def prep_string_for_comment(length, separator, center, text2align):
    if text2align == '':
        # Only delimiter
        line_out = separator*(length+3)
    elif center:
        # Centered text
        line_out = separator + text2align.center(length) + separator
    else:
        # Left aligned text
        line_out = separator + ' ' + text2align + (' ' * (length - len(text2align))) +separator
    return line_out + '\n'

def prep_value_for_conf(comment, name, value):
    if comment != '':
        lines_out = '# ' + comment + '\n'
    else:
        lines_out = ''
    lines_out = lines_out + name + " = " + value + '\n'
    return lines_out

def add_option(options, next_option, value):
    if value == '':
        new_option = next_option
    else:
        new_option = next_option + '=' + value
    options.append('--' + new_option)

def get_other_members(list_of_mongod):
    other_members= ''
    for mongo in list_of_mongod:
        if other_members != '':
            other_members = other_members + ','
        other_members = other_members + mongo.ip + ':' + str(mongo.port)
    return(other_members)

###################################################
# Classes                                         #
###################################################

class generalParams:
    def __init__(self, name, data, etc, log, var, lbin,  baseFolder, port, ip, inc_port, inc_ip, mask_ip, mongoCredentials, mongoLocation, init_script, data_location):
        self.name = name
        self.baseFolder = baseFolder
        self.data = self.baseFolder + data
        self.etc  = self.baseFolder + etc
        self.log  = self.baseFolder + log
        self.var  = self.baseFolder + var
        self.lbin = self.baseFolder + lbin
        self.port = port
        self.ip   = socket.inet_aton(ip)
        self.inc_port = inc_port
        self.inc_ip   = inc_ip
        self.mask_ip  = mask_ip
        self.next_port = self.port + self.inc_port
        self.next_ip   = self.ip
        self.mongoCredentials = mongoCredentials
        self.mongoCredentials.key_file = self.data+'/'+self.name+'.shared-key.txt'
        self.mongoLocation = mongoLocation
        self.dataLocation  = data_location
        self.start_options = []
        if init_script != '':
            f_in = open(init_script, 'r')
            init_template = Template(f_in.read())
            f_in.close()
        else:
            logging.debug("Using internally defined init scrip")
            init_template = Template(init_scrip)
        self.init_script = init_template.safe_substitute(ClusterInABox='Cluster in a box - version 0.1')


    def createFolders(self):
        subprocess.call(['mkdir', '-p', self.etc]) 
        subprocess.call(['mkdir', '-p', self.etc +'/init.d']) 
        subprocess.call(['mkdir', '-p', self.log]) 
        subprocess.call(['mkdir', '-p', self.var]) 
        subprocess.call(['ln', '-s', self.mongoLocation + '/bin', self.lbin]) 
        if self.dataLocation == '':
            subprocess.call(['mkdir', '-p', self.data]) 
        else:
            print self.dataLocation, self.data
            subprocess.call(['ln', '-s',  self.dataLocation, self.data])

        self.mongoCredentials.createKeyFile(self.mongoCredentials.key_file)

    def dropFolders(self):
        subprocess.call(['rm', '-rf', self.baseFolder])

    def getNextPort(self):
        presentPort = self.next_port
        self.next_port = self.next_port + self.inc_port
        return presentPort

    def getNextIP(self):
        presentIP = self.next_ip
        # increment present IP by one and check the mask using some network library
        # self.next_ip , self.inc_ip, self.mask_ip
        return socket.inet_ntoa(presentIP)

    def print_v(self):
        print "-------------------------------------------- generalParams"
        pprint.pprint (vars(self))


class mongoSecurity:
    def __init__(self, user, password, key_pass):
        self.user  = user
        self.password = password
        self.key_file = 'default.shared-key.txt'
        self.key_pass = key_pass
        # Enable authentication if a username is provided
        self.authentication_enabled = (self.user != '')

    def createKeyFile(self, fullFileName):
        self.key_file = fullFileName
        try:
            file_key = open(self.key_file, 'r')
            # Read contents
        except IOError:
            file_key = open(self.key_file, 'w')
            file_key.write(self.key_pass + '\n')
            file_key.close()
            # Key file with shared secret requieres strict read permissions (600)
            subprocess.call(['chmod', '600', self.key_file])

class mongodbInstance:
    def __init__(self, parentname, name, data_location, conf_file, pid_file, log_file, mongo_type, ip, port, credentials, journaled, binary):
        self.parentname = parentname
        self.name = name
        self.data_location = data_location
        self.conf_file = conf_file + '/' + self.name + '.conf'
        self.pid_file = pid_file + '/' + self.name + '.pid'
        self.log_file = log_file + '/' + self.name + '.log'
        self.mongo_type = mongo_type
        self.ip = ip
        self.port = port
        self.credentials = credentials
        self.auth = self.credentials.authentication_enabled
        self.journaled = journaled
        #self.status = 'UnKnown'
        self.rest = 'false'
        self.fork = 'true'
        self.init_script_file = conf_file + '/init.d/' + self.name + '.mongod'
        self.client = None 
        self.connection = None
        self.admin = None
        self.mongo_status = None
        self.options = [binary]
        self.binary = binary
        self.related_mongos = []
        self.is_configured = False

    def create_conf_file(self, init_script):
        subprocess.call(['mkdir', '-p', self.data_location])
        fcg = open(self.conf_file, 'w')
        fcg.write( prep_string_for_comment(40, '#', False, '') )
        fcg.write( prep_string_for_comment(40, '#', False, 'Autogenerated conf file') )
        fcg.write( prep_string_for_comment(40, '#', False, self.name) )
        fcg.write( prep_string_for_comment(40, '#', False, ' ') )
        fcg.write( prep_string_for_comment(40, '#', False, '') )
        fcg.write( prep_value_for_conf("Full pathname for the log file", "logpath", self.log_file) )
        add_option(self.options, 'logpath', self.log_file)
        fcg.write( prep_value_for_conf("Append to the log: preserves the previous contents across restarts", "logappend", 'true') )
        add_option(self.options, 'logappend', '')
        fcg.write( prep_value_for_conf("IP to bind to", "bind_ip", self.ip) )
        add_option(self.options, 'bind_ip', self.ip)
        fcg.write( prep_value_for_conf("Port to use", "port", str(self.port)) )
        add_option(self.options, 'port', str(self.port))
        fcg.write( prep_value_for_conf("rest Interface enabled", "#rest", self.rest) )
        fcg.write( prep_value_for_conf("Become Daemon", "fork", self.fork) )
        add_option(self.options, 'fork', '')

        # mongos instances don't requiere a data directory
        if self.mongo_type != 'mongos':
            fcg.write( prep_value_for_conf("Absolute path for the data folder", "dbpath", self.data_location) )
            add_option(self.options, 'dbpath', self.data_location)
            fcg.write( prep_value_for_conf("Use an single folder for each database (recommended)", "directoryperdb", 'true') )
            add_option(self.options, 'directoryperdb', '')
            fcg.write( prep_value_for_conf("Do not use a journaled system", "journal", 'false' ) )
            fcg.write( prep_value_for_conf("Do not use a journaled system: take two", "nojournal", 'true' ) )
            add_option(self.options, 'nojournal', '')
            fcg.write( prep_value_for_conf("Do not preallocate space for the files in a test environment", "noprealloc", 'true' ) )
            add_option(self.options, 'noprealloc', '')
            fcg.write( prep_value_for_conf("Just for local tests and debugging: remove on real systems", "oplogSize", str(192)))
            add_option(self.options, 'oplogSize', '192')
            if self.auth:
                fcg.write( prep_value_for_conf("Enable Authentication on this instance", "auth", 'true') )
            else:
                add_option(self.options, 'noauth', '')
                fcg.write( prep_value_for_conf("Enable Authentication on this instance", "auth", 'false') )

        
        fcg.write( prep_value_for_conf("Full pathname for the pid file", "pidfilepath", self.pid_file) )
        add_option(self.options, 'pidfilepath', self.pid_file)
        fcg.write( prep_value_for_conf("Full pathname for the keyFile to use", "keyFile", self.credentials.key_file) )
        add_option(self.options, 'keyFile', self.credentials.key_file)
        if self.mongo_type.startswith('replSet'):
            # Get the connection parameters for the other members of the replica set
            fullRepSetCfg = self.parentname+'/' + get_other_members(self.related_mongos) 
            fullRepSetCfg = self.parentname+'/' + get_other_members(self.related_mongos)
            fcg.write( prep_value_for_conf("Instance part of a replica set:" + self.mongo_type, "replSet", fullRepSetCfg ))
            add_option(self.options, 'replSet', fullRepSetCfg)
        elif self.mongo_type == 'configsvr':
            fcg.write( prep_value_for_conf("Instance is a config database in a cluster", "configsvr", 'true'))
            add_option(self.options, 'configsvr', '')
        elif self.mongo_type == 'mongos':
            # The mongos entry for a sharded environment
            # mongos instances do not allow localhost IPs (127.0: loop devices) for the config servers.
            # If it appears in the list, replace it with the local hostname
            fullCfgList = get_other_members(self.related_mongos)
            fcg.write(prep_value_for_conf("Instance is the mongos service for a sharded environment", 'configdb', fullCfgList))
            add_option(self.options, 'configdb', fullCfgList)
        fcg.close()

        file_init = open(self.init_script_file, 'w')
        cnt_init_script = Template(init_script).safe_substitute(NameOfInstance=self.name, MongoConfigFile=self.conf_file, MongoPIDFile=self.pid_file, mongod_binary=self.binary)
        file_init.write(cnt_init_script)
        file_init.close()
        subprocess.call(['chmod', '700', self.init_script_file])

        # For debug
        file_init = open(self.init_script_file+'.safe', 'w')
        file_init.write(' '.join(self.gen_start_safe_options(self.binary)))
        file_init.close()
        #subprocess.call(['chmod', '700',self.init_script_file+'.safe')

    def add_related_mongos(self, mongos_list):
        for mongo in mongos_list:
            if self.name != mongo.name:
                self.related_mongos.append(mongo)


    def print_v(self):
        print "-------------------------------------------- mongodbInstance"
        pprint.pprint (vars(self))

    def add_admin_account(self):
        self.admin.add_user(self.credentials.user, self.credentials.password, roles = ["userAdminAnyDatabase", "dbAdminAnyDatabase", "readWriteAnyDatabase", "clusterAdmin"] )

    def connect2admin(self):
        self.admin = self.connection.admin
        # Authenticate if the instance has already been configured and is not an 'Arbiter' in a rs
        if self.is_configured and self.mongo_type != 'replSet.Arbiter':
            self.admin.authenticate(self.credentials.user, self.credentials.password)

    def start(self, safe=False, safe_delay=5):
        print "Starting " + self.name 
        if safe:
            self.subp = subprocess.Popen(self.gen_start_safe_options(self.binary),shell=False)
            # Attempt to connect for at least five seconds
            self.connect(safe_delay)
            self.server_status()
        else:
            #pdb.set_trace()
            self.subp = subprocess.Popen(self.options,shell=False)

    def stop(self):
        print "Stoping " + self.name
        self.connect()
        if self.admin != None:
            self.shutdown()

    def get_pid(self):
        if os.path.isfile(self.pid_file):
            pid = int(file(self.pid_file,'r').readlines()[0])
        else:
            pid = 0
        return(pid)

    def kill(self):
        pid = self.get_pid()
        print "Killing " + self.name + " - pid = " + str(pid)
        if pid > 0:
            try:
                os.kill(pid, signal.SIGKILL)
            except OSError as e:
                print "OS error number " + str(e.errno)
                print e.strerror
            subprocess.call(['rm', self.pid_file])
        self.clean_connection()

    def gen_start_safe_options(self, bin2run):
        options = [bin2run]
        add_option(options, 'bind_ip', self.ip)
        add_option(options, 'port', str(self.port))
        add_option(options, 'pidfilepath', self.pid_file)
        add_option(options, 'logpath', self.log_file+'.cfg_run')
        if self.mongo_type != 'mongos':
            add_option(options, 'dbpath', self.data_location)
            add_option(options, 'directoryperdb', '')
            add_option(options, 'nojournal', '')
            add_option(options, 'noprealloc', '')
            add_option(options, 'noauth', '')
            # Remove this option for production systems or provide a far more sensitive value
            add_option(options, 'oplogSize', '192')
        add_option(options, 'logappend', '')
        add_option(options, 'nohttpinterface', '')
        #pdb.set_trace()
        if self.mongo_type.startswith('replSet'):
            add_option(options, 'replSet', self.parentname)
        elif self.mongo_type == 'configsvr':
            print 'configsvr'
            add_option(options, 'configsvr', '')
        elif self.mongo_type == 'mongos':
            fullCfgList = get_other_members(self.related_mongos)
            add_option(options, 'configdb', fullCfgList)
        return(options)


    def config(self, mongo_type='replSet.Node'):
        print "Configuring "+self.name
        if self.connection == None:
            self.connect()
        
        if self.mongo_type == 'configsvr' or mongo_type == 'replSet.Master':
            # Add admin user
            self.add_admin_account()

        # Flag this instance as already configured
        self.is_configured = True

    def shutdown(self, timeout = 30):
        print "Shutting down "+ self.name
        if self.connection == None:
            self.connect()
        try:
            # The timeout will give primaries/masters of repsets a chance for the secondaries to get up to date before shutting down
            self.admin.command(bson.son.SON([ ('shutdown',1), ('timeoutSecs', timeout) ]))
        except pymongo.errors.AutoReconnect:
            print "mongodb died gracefully..."
            self.clean_connection()
            subprocess.call(['rm', self.pid_file])
        except pymongo.errors.OperationFailure:
            print self.name + " could not be shutdown!!!!!!!!!!!!!!!!!!!!"
            #time.sleep(1)
            #self.shutdown()

    def clean_connection(self):
        self.connection = None
        self.admin = None

    def killS(self):
        print "kill " + self.name
        #subprocess.call([self.init_script_file, 'kill'])

    def connect(self, time2reattempt=0):
        print "Connecting to "+ self.name
        if time2reattempt > 0:
            reconnections_attempts = time2reattempt*10
            while reconnections_attempts > 0:
                try:
                    #self.connection = pymongo.MongoClient(self.ip, self.port, connectTimeoutMS=time2reattempt*1000)
                    self.connection = pymongo.MongoClient(self.ip, self.port)
                    break
                except pymongo.errors.ConnectionFailure:
                    time.sleep(0.1)
                    reconnections_attempts = reconnections_attempts - 1
            if reconnections_attempts <= 0:
                logging.critical('Failed to connect to ' + self.name)
            else:
                self.connect2admin()
        else:
            try:
                self.connection = pymongo.MongoClient(self.ip, self.port)
                self.connect2admin()
            except pymongo.errors.ConnectionFailure:
                logging.critical('Failed to connect to ' + self.name)

    def run_command(self, command2run, json2pass=None):
        #print command2run, json2pass
        if self.connection == None:
            # Open a connection first
            self.connect()
        if json2pass == None:
            res = self.admin.command(command2run)
        else:
            res = self.admin.command(command2run, json2pass)
        return(res)

    def check_rep_set_status(self, rscheck='Connected', res=None):
        resCheck = False
        if rscheck=='IsRepSetConfigured':
            if (res != None) and ('setName' in res):
                resCheck = True
        return resCheck

    def server_status(self, verbose = False, force_run=False):
        if self.mongo_status == None or force_run:
            self.mongo_status = self.run_command('serverStatus')
        if verbose:
            printplus(self.mongo_status)

    def status(self, status_requested='full'):
        print '-' * 50
        print self.name + ': ' + self.mongo_type
        self.connect(2)
        if self.admin == None:
            print "Not running"
        else:
            mongo_status = self.run_command('serverStatus')
            if status_requested=='full':
                print 'pplus output'
                printplus(mongo_status)
                print 'pprint output'
                pprint.pprint(mongo_status, indent=4)
            else:
                print 'Running'


    def IsPrimary(self):
        # Returns true if this mongo is the primary node of a replicaset
        #pdb.set_trace() 
        #print '----- ismaster'
        ismaster = self.run_command('ismaster')
        #printplus(ismaster)
        return(ismaster['ismaster'])

        print '---'
        self.server_status(verbose=True, force_run=True)
        try:
            replset_status = self.mongo_status['repl']
            #printplus(replset_status)
            IsIt = replset_status['ismaster']
        except KeyError:
            logging.debug(self.name + ' was tested for primary status in a replica set but it is a standalone process')
            IsIt = False

        return(IsIt)

class mongodbReplicaSet:
    def __init__(self, replica_size, replica_type, shard_name, sufix, clusterParams):
        self.replica_size = replica_size
        self.replica_type = replica_type
        self.name = shard_name + ".rs"
        self.clusterParams = clusterParams
        self.mongo_instances = [ self.get_mongodbInstance(i) for i in range(1, replica_size+1) ]
        for mongo in self.mongo_instances:
            mongo.add_related_mongos(self.mongo_instances)

    def get_mongodbInstance(self, i):
        base_name = self.name + "." + str(i)
        if i == self.replica_size:
            # The last member to add is the arbiter
            repsettype = 'replSet.Arbiter'
        else:
            repsettype = 'replSet.Node'
        mdb = mongodbInstance(self.name, base_name,\
                              self.clusterParams.data+'/'+base_name,\
                              self.clusterParams.etc,\
                              self.clusterParams.var,\
                              self.clusterParams.var,\
                              repsettype,\
                              self.clusterParams.getNextIP(),\
                              self.clusterParams.getNextPort(),\
                              self.clusterParams.mongoCredentials,\
                              False,\
                              self.clusterParams.lbin+'/mongod')
        return(mdb)

    def createReplicaSet(self):
        for mongo in self.mongo_instances:
            mongo.create_conf_file(self.clusterParams.init_script)

    def print_v(self):
        logging.debug("-------------------------------------------- mongodbReplicaSet")
        logging.debug(pprint.pformat(vars(self)))
        for mongoins in self.mongo_instances:
            mongoins.print_v()

    def start(self):
        for mongoins in self.mongo_instances:
            mongoins.start()

    def stop(self):
        for mongoins in self.mongo_instances:
            mongoins.stop()

    def shutdown(self):
        # Shut them down
        for mongo in self.mongo_instances:
            mongo.shutdown()

    def status(self,status_requested):
        for mongoins in self.mongo_instances:
            mongoins.status(status_requested)

    def get_member_parms(self, i):
        mongo = self.mongo_instances[i]
        if mongo.mongo_type == 'replSet.Arbiter':
            member = { '_id': i,
                      'host': mongo.ip+':'+str(mongo.port),
                      'arbiterOnly': 'true'}
        else:
            member = { '_id': i,
                      'host': mongo.ip+':'+str(mongo.port)}

        logging.debug(pprint.pformat(member))
        return member

    def get_list_of_members(self):
        # Return a list of members
        members = [self.get_member_parms(i) for i in range(0, self.replica_size) ] 
        return members

    def config(self):
        print "Configuring replica set" + self.name
        # First, start the mongos in safe mode
        for mongo in self.mongo_instances:
            mongo.start('safe')
        # Give them a chance to get up (wait a few seconds)
        #self.mongo_instances
        time.sleep(1)

        # Configure all of them
        repSetConfig = { '_id': self.name,
                        'members': self.get_list_of_members()
                       }
        self.mongo_instances[0].run_command('replSetInitiate', repSetConfig)

        print 'Waiting one minute or until the replicaset has selfconfigured itself'
        for i in range(1, 60):
            rep_set_status = self.mongo_instances[0].run_command('isMaster')
            #print "rep_set_status: " 
            #printplus(rep_set_status)
            if self.mongo_instances[0].check_rep_set_status('IsRepSetConfigured', rep_set_status):
                print self.mongo_instances[0].parentname + ' is configured'
                break
            time.sleep(1)

        # Flag all the members as configured, though there is one more piece missing: adding the admin account once
        # the master of the replicaset has already been established
        # Run any selfconfiguration options that are requiered (for instance, adding the admin user and enabling authentication
        #mongo_master = self.getPrimaryNode
        #master_detected = False
        for mongo in self.mongo_instances:
            mongo.is_configured = True
            #if not master_detected and mongo.IsPrimary():
            #    mongo.config('replSet.Master')
            #    master_detected = True
            #else:
            #    mongo.config()

        #if not master_detected:
        #    print "Critical error: master was not detected in this replicaset"


    def kill(self):
        for mongoins in self.mongo_instances:
            mongoins.kill()

    def add_admin_account(self):
        mongo_master = self.getPrimaryNode()
        mongo_master.config('replSet.Master')

    def getPrimaryNode(self):
        # Gets the primary node of the replicaset and returns it
        print "Looking for the master of " + self.name
        cycles2try = 15
        while cycles2try > 0:
            for mongo in self.mongo_instances: 
                if mongo.IsPrimary():
                    logging.debug('Found master: ' + mongo.name)
                    return(mongo)
            # A master was not found in the entire replicaset. Possible still self-configuring.
            # Wait one second and try again.
            time.sleep(1)
            logging.debug("Still looking for the master or " + self.name + " " + str(cycles2try) + " more attempts to go...")
            cycles2try = cycles2try - 1


class mongodbConfigSet:
    def __init__(self, clusterParams, k_config_servers):
        self.clusterParams = clusterParams
        self.size = k_config_servers
        self.configMongodbs = [self.get_mongodbInstance(i) for i in range(1, self.size+1) ]
        for mongo in self.configMongodbs:
            mongo.add_related_mongos(self.configMongodbs)

    def get_mongodbInstance(self, i):
        base_name = self.clusterParams.name + '.cfg.' + str(i)
        mdb = mongodbInstance(self.clusterParams.name, base_name,\
                              self.clusterParams.data+'/'+base_name,\
                              self.clusterParams.etc,\
                              self.clusterParams.var,\
                              self.clusterParams.var,\
                              'configsvr',\
                              self.clusterParams.getNextIP(),\
                              self.clusterParams.getNextPort(),\
                              self.clusterParams.mongoCredentials,\
                              True,\
                              self.clusterParams.lbin+'/mongod')
        return(mdb)

    def createConfigMongos(self):
        for mongo in self.configMongodbs:
            mongo.create_conf_file(self.clusterParams.init_script)

    def print_v(self):
        logging.debug("-------------------------------------------- mongodbConfigSet")
        logging.debug(pprint.pformat(vars(self)))
        for config in self.configMongodbs:
            config.print_v()

    def start(self):
        for mongo in self.configMongodbs:
            mongo.start()

    def stop(self):
        for mongo in self.configMongodbs:
            mongo.stop()

    def status(self, status_requested):
        for mongo in self.configMongodbs:
            mongo.status(status_requested)

    def shutdown(self):
        for mongo in self.configMongodbs:
            mongo.shutdown()


    def config(self, mongos_process, shardNodes):
        print "Configuring the mongo shards configs"
        # First, start the mongos in safe mode
        for mongo in self.configMongodbs:
            mongo.start(safe=True)

        mongos_process.start(safe=True, safe_delay=15)

        # Configure all of them
        for mongo in self.configMongodbs:
            mongo.config()

        # Initiate the mongos process: mongos will need a detail of the shards that it should connect to.
        print "Adding the individual shards (repset masters) to the mongos cluster"
        mongodbsPrimary = [shard.getPrimaryNode() for shard in shardNodes]
        #pdb.set_trace()
        for rs in mongodbsPrimary:
            mongos_process.run_command('addShard', rs.parentname + '/' + rs.ip + ':' + str(rs.port))
        time.sleep(1)

    def kill(self):
        for mongo in self.configMongodbs:
            mongo.kill()



class mongodbShard:
    def __init__(self, sufix, replica_size, replica_type, clusterParams):
        self.name = clusterParams.name +'.shard.' + str(sufix)
        self.sufix = sufix
        self.replica_size = replica_size
        self.clusterParams = clusterParams
        self.replicaset = mongodbReplicaSet(replica_size, replica_type, self.name, self.sufix, self.clusterParams)

    def createRepSetMongos(self):
        self.replicaset.createReplicaSet()

    def print_v(self):
        logging.debug("-------------------------------------------- mongodbShard")
        logging.debug(pprint.pformat(vars(self)))
        self.replicaset.print_v()

    def start(self):
        self.replicaset.start()

    def stop(self):
        self.replicaset.stop()

    def status(self, status_requested):
        self.replicaset.status(status_requested)

    def shutdown(self):
        self.replicaset.shutdown()

    def config(self):
        self.replicaset.config()

    def kill(self):
        self.replicaset.kill()

    def getPrimaryNode(self):
        # Gets the primary node of the replicaset and returns it
        return(self.replicaset.getPrimaryNode())

    def add_admin_account(self):
        self.replicaset.add_admin_account()


class mongodbCluster:
    def __init__(self, cluster2load='', clusterParams=None, nodes=0, config_size=0, replica_size=0, replica_type='Simple', cluster_type='Simple'):
        if cluster2load != '':
            self.loadCluster(cluster2load)
        else:
            self.nodes = nodes
            self.replica_size = replica_size
            self.replica_type = replica_type
            self.clusterParams = clusterParams
            self.is_configured = False
            self.configClsts = mongodbConfigSet(self.clusterParams, config_size)
            self.shardNodes = [ mongodbShard(i, self.replica_size, self.replica_type, self.clusterParams ) for i in range(1, self.nodes+1) ]
            # the mongos process. Type 'mongos'
            self.mongos_process = self.create_mongos_instance()

    def create_mongos_instance(self):
        # The mongos process will use the firt port assigned for this cluster: Just to make it easy to identify the port that the
        # apps should aim to. Otherwise the devs should take a look at the config files to see what port was sequentially assigned
        # to the mongos service
        base_name  = self.clusterParams.name + '.mongos'
        mdb = mongodbInstance(self.clusterParams.name, base_name,\
                              self.clusterParams.data+'/'+base_name,\
                              self.clusterParams.etc,\
                              self.clusterParams.var,\
                              self.clusterParams.var,\
                              'mongos',\
                              socket.inet_ntoa(self.clusterParams.ip),\
                              self.clusterParams.port,\
                              self.clusterParams.mongoCredentials,\
                              True,\
                              self.clusterParams.lbin+'/mongos')
        mdb.add_related_mongos(self.configClsts.configMongodbs)
        return(mdb)


    def cleanCluster(self):
        self.clusterParams.dropFolders()

    def createCluster(self):
        self.cleanCluster()
        self.clusterParams.createFolders()

        self.configClsts.createConfigMongos()
        for shard in self.shardNodes:
            shard.createRepSetMongos()
        self.mongos_process.create_conf_file(self.clusterParams.init_script)

        #pdb.set_trace()

    def print_v(self):
        logging.debug("-------------------------------------------- mongodbCluster")
        self.clusterParams.print_v()
        self.mongos_process.print_v()
        self.configClsts.print_v()
        for shard in self.shardNodes:
            shard.print_v()

    def start(self):
        if not self.is_configured:
            self.config()
        self.configClsts.start()
        for shard in self.shardNodes:
            shard.start()

        # Wait for the other mongodbs before attemting to start the mongos process
        for mongo in self.configClsts.configMongodbs:
            mongo.connect(2)
        for srd in self.shardNodes:
            for mongo in srd.replicaset.mongo_instances:
                mongo.connect(2)

        self.mongos_process.start()

    def stop(self):
        self.mongos_process.stop()
        self.configClsts.stop()
        for shard in self.shardNodes:
            shard.stop()

    def status(self, status_requested):
        self.configClsts.status(status_requested)
        for shard in self.shardNodes:
            shard.status(status_requested)
        self.mongos_process.status(status_requested)

    def shutdown(self):
        self.configClsts.shutdown()
        for shard in self.shardNodes:
            shard.shutdown()
        self.mongos_process.shutdown()

    def config(self):
        # Configure the replicasets firts, the configs later
        for shard in self.shardNodes:
            shard.config()
        
        # Configure the config mongod
        self.configClsts.config(self.mongos_process, self.shardNodes)

        # Finally, configure the mongos instance
        self.mongos_process.config()

        # The final step once the replicaset had already selfconfigured is to add the admin account in the master of each one
        for shard in self.shardNodes:
            shard.add_admin_account()
 


        # This was a configuration run only, stop the services
        self.shutdown()

        self.is_configured = True
        #pdb.set_trace()
        self.saveCluster()

    def kill(self):
        self.configClsts.kill()
        for shard in self.shardNodes:
            shard.kill()
        self.mongos_process.kill()

    def saveCluster(self):
        pickle.dump(self,  open(self.clusterParams.name + '.clb', 'wb'))



def parse_options():
    parser = OptionParser(usage="Usage: %prog [options] action (create|start|stop)")
    parser.add_option("-u", "--user", dest="mongo_user", default="local_user", help="Mongodb user")
    parser.add_option("-p", "--password", dest="password", default="1234abc", help="Mongodb password")
    parser.add_option("-k", "--key-phrase", dest="keyphrase", default="abc1234XYZ987", help="Shared secret key for all the mongos")
    parser.add_option("-P", "--port", dest="port", type="int", default=27017, help="Base port to use (default: 27017)")
    parser.add_option("-q", "--port-increments", dest="port_inc", type="int", default=1, help="Port increments to use from one local mongo to the next")
    parser.add_option("-I", "--ip", dest="base_ip", default="127.0.0.1", help="Base IP to use to bind the mongo instances: the lowest goes to mongos")
    parser.add_option("-i", "--ip-increments", dest="ip_inc", type="int", default=0, help="IP increments to use from one IP based mongo to the next")
    #parser.add_option("-M", "--mongo-version", dest="mongo_version", default="mongodb-linux-x86_64-2.4.1", help="Mongo version to use")
    parser.add_option("-M", "--mongo-version", dest="mongo_version", default="", help="Mongo version to use")
    parser.add_option("-C", "--cluster-name", dest="cluster_name", default="localCluster", help="Name of the cluster. It will be used to generate the parent folder for all the subdirectories to be used")
    parser.add_option("-D", "--DataLocation", dest="data_location", default="", help="Folder where all the data will be kept")
    parser.add_option("-c", "--config", dest="config_file", default="", help="Config file to use: Json format")
    parser.add_option("-T", "--cluster-type", dest="cluster_type", default="simple", help="Cluster type")
    parser.add_option("-n", "--nodes", dest="nodes", type="int", default=2, help="Number of nodes in the cluster")
    parser.add_option("-g", "--config-instances", dest="config_instances", type="int", default=3, help="Number of config mongos in the cluster")
    parser.add_option("-r", "--repset-size", dest="repset_size", type="int", default=3, help="Size in mongos of each replica set")
    parser.add_option("-R", "--repset-type", dest="repset_type", type="int", default=1, help="Type of the repset to use: 0: (2 + 1 arbiter); 1: (three full)")
    parser.add_option("-l", "--log-level", dest="log_level", type="int", default=1, help="Log level (1 to 5)" )
    parser.add_option("-f", "--log-file", dest="log_file", default="cluster_in_a_box.log", help="Log filename" )
    (options, args) = parser.parse_args()

    if len(args) == 0:
        parser.print_help()
        parser.error("You have to define at least one action")
    elif len(sys.argv) == 1:
        parser.print_help()
        parser.error("You have to provide at least one valid argument")
    else:
        action=args[0]
    return  (options, args)

def main():
    # One global variable so far:
    (options, args) = parse_options()
    action=args[0]
    log_list = [logging.NOTSET, logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL]
    logging.basicConfig(filename=options.log_file, filemode='a', level=log_list[options.log_level], format='%(asctime)s %(message)s')
    mongo_location = unpack_mongodb (options.mongo_version, os.getcwd())
    baseFolder   = os.getcwd() + '/' + options.cluster_name + '/'

    if action == 'create':
        mongoCredentials = mongoSecurity(options.mongo_user,options.password,options.keyphrase)
        clusterParams = generalParams(options.cluster_name, 'data', 'etc', 'log', 'var', 'bin', baseFolder, options.port, options.base_ip, options.port_inc, options.ip_inc, 32, mongoCredentials, mongo_location, '', options.data_location)
        globalCluster = mongodbCluster('', clusterParams, options.nodes, options.config_instances, options.repset_size, options.repset_type, options.cluster_type)

        globalCluster.createCluster()
        globalCluster.print_v()
        pickle.dump(globalCluster,  open(options.cluster_name + '.clb', 'wb'))
        sys.exit(0)

    # Load present defined values for the cluster
    globalCluster = pickle.load(open(options.cluster_name + '.clb', 'rb'))
    if action == 'print':
        globalCluster.print_v()
    elif action == 'config':
        print '----- config'
        globalCluster.config()
    elif action == 'start':
        print '----- start'
        globalCluster.start()
        # Just to make it look clean: Wait one seconds for the childs to complete upping and get a nice prompt upon finalization
        time.sleep(1)
    elif action == 'stop':
        print '----- stop'
        globalCluster.stop()
    elif action == 'kill':
        print '----- kill'
        globalCluster.kill()
    elif action == 'debug':
        print '----- debug'
        pdb.set_trace() 
    elif action == 'status':
        print '----- status'
        globalCluster.status('simple')
    elif action == 'fullstatus':
        print '----- fullstatus'
        globalCluster.status('full')
    else:
        print 'Unknown action'

    sys.exit(1)

if __name__ == "__main__":

    main()

